<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/Console.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD><SCRIPT SRC="../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../index.html";</SCRIPT><link href="../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 1;
   parent.leftFrame.expandToItem('tree2', 'doc1');
   var element = parent.leftFrame.document.getElementById('doc1');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Console</title>
<link href="torque.css" rel="stylesheet" type="text/css">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066">
<div align="center">

<table width=700 cellspacing=0 cellpadding=10 border=0 bgcolor="#ffffff" summary="">
<tr><td>


<!-- Generated by Doxygen 1.5.4 -->
<h1><a class="anchor" name="Console"></a><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a>Console </h1><h2><a class="anchor" name="ConOverview"></a><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a>Overview</h2>
The console module, rooted in engine/console/console.h, is a combined compiler and interpreter runtime that serves as the foundation for Torque applications. All GUIs, game objects, interfaces, and game logic are handled through the console. The language itself is syntactically similar to a typeless C++, with some additional features that allow for easier mod development. Console scripts can be loaded via the exec() console command from the console window (brought up using the ~ key) or they can be loaded automatically from a mod via that mod's main.cs.
<h2><a class="anchor" name="ConRef"></a><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a>Console Language Reference</h2>
The Torque console language scanner and parser were built using the tools lex and yacc. The scan and grammar files are engine/console/scan.l and engine/console/gram.y respectively. The grammar is shown in a somewhat more understandable way in the attached document.
<h2><a class="anchor" name="ConFunctions"></a><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a>Functions</h2>
Console functions can be declared in either console scripts or in the C++ game/engine code.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// A simple script function declaration.</span>
function helloWorld ()
{
    echo(<span class="stringliteral">"Hello World!"</span>);
}

<span class="comment">// Let's call it!</span>
helloWorld();

<span class="comment">// Or, for a method on a class:</span>
function SimObject::helloWorld(%<span class="keyword">this</span>)
{
    echo(<span class="stringliteral">"Hello World!"</span>);
    echo(<span class="stringliteral">"Called on object: "</span> @ %<span class="keyword">this</span>);
}

<span class="comment">// And call it...</span>
$object = <span class="keyword">new</span> SimObject();
$object.helloWorld();
</pre>
</div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Unlike in C++, the "this" variable is not implicit in a script's method declaration. Instead, the first parameter to a method is always the object whose method is being called. It is traditional but not required to call this parameter this; a common variant is db, for methods of datablocks.</dd></dl>
To declare console functions in the game or engine code, the ConsoleFunction macro (declared in engine/console/console.h) should be used:<p>
<div class="fragment"><pre class="fragment">ConsoleFunction(helloWorld, <span class="keywordtype">void</span>, 1, 1, <span class="stringliteral">"A simple test function."</span>)
{
    Con::printf(<span class="stringliteral">"Hello World!"</span>);
}
</pre>
</div><p>
A rundown of the arguments to the ConsoleFunction macro:<ul>
<li>First is the name of the function, followed by the type.</li><li>Second, come the minimum and maximum number of allowed arguments. The function name is "argument 0", so 1 is the minimum argument count allowed. Passing a 0 for max arguments will allow any number of arguments to the function.</li><li>Finally, the usage string. This serves a dual purpose. See <a class="el" href="../Engine%20Reference/console_autodoc.html">this page</a> for a more in-depth exploration of how the string can be used to autogenerate Doxygen compatible documentation from within your program. However, the string mostly exists to provide as feedback to users if they make a console function call with the wrong number of arguments.</li></ul>
<p>
Methods for classes can also be declared in C++, using the ConsoleMethod macro:<p>
<div class="fragment"><pre class="fragment">ConsoleMethod(SimObject, helloWorld, <span class="keywordtype">void</span>, 2, 2, <span class="stringliteral">"A somewhat more complex test method."</span>)
{
    Con::printf(<span class="stringliteral">"Hello World!"</span>);
    Con::printf(<span class="stringliteral">"Called on object: %s"</span>, argv[1]);
    Con::printf(<span class="stringliteral">"Also called on object: %s"</span>, object-&gt;getName());
}
</pre>
</div><p>
This defines a method callable on any instance of a <a class="el" href="../Engine%20Reference/a01077.html" title="Base class for objects involved in the simulation.">SimObject</a> the console has access to.
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Three useful parameters are provided to the code in the body of a ConsoleFunction or ConsoleMethod:<ul>
<li>int argc, indicating how many arguments were passed.</li><li>const char* argv[], an array of strings corresponding to the arguments.</li><li>object, which is present only in the case of a ConsoleMethod, is a pointer to the object on which the method is being called. It is automatically cast and validated, so you don't need to cast it yourself (this was the case in older versions of Torque).</li>
</ul>
</dd></dl>
<h2><a class="anchor" name="ConClasses"></a><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a>Classes, Objects and Namespaces</h2>
<h3><a class="anchor" name="ConClasses_declaring"></a><a name = "HeaderLink5"></a><a name = "HeaderLink5"></a><a name = "HeaderLink5"></a>Declaring Console Classes</h3>
Objects in the scripting language are simply instances of C++ classes deriving from <a class="el" href="../Engine%20Reference/a01077.html" title="Base class for objects involved in the simulation.">SimObject</a>, declared in the game engine and processed with a special set of macros (declared in engine/console/consoleObject.h). The DECLARE_CONOBJECT(class_name) macro is placed inside the class definition and the IMPLEMENT_CONOBJECT (class_name) macro is placed in a linked source file. IMPLEMENT_CONOBJECT has several versions, depending on the type of class:
<ul>
<li><b>IMPLEMENT_CONOBJECT()</b> A simple console object - no special network attributes.</li>
</ul>
<p>
<ul>
<li><b>IMPLEMENT_CO_NETOBJECT_V1()</b> A ghostable network object class. Any object that will be ghosted from server to client needs to be declared as a NETOBJECT. See the section on the network layer for more details about NetObjects.</li>
</ul>
<p>
<ul>
<li><b>IMPLEMENT_CO_DATABLOCK_V1()</b> A datablock class. Datablocks have special properties for being transmitted over the network.</li>
</ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There are 3 more IMPLEMENT_CONOBJECTs that deal specifically with network events. They are not covered here.</dd></dl>
Every class declared as a Console class MUST declare a Parent typedef in its private member section referencing its parent class. This allows the console to properly determine the console object class hierarchy for method dispatch in the console.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// A very simple SimObject sample.</span>
<span class="keyword">class </span>SampleObject : <span class="keyword">public</span> SimObject
{
    <span class="keyword">typedef</span> SimObject Parent;
<span class="keyword">public</span>:
    DECLARE_CONOBJECT(SampleObject);
    S32 someVariable; <span class="comment">// signed integer variable</span>
};
IMPLEMENT_CONOBJECT(SampleObject);
</pre>
</div><p>
You can instantiate and manipulate this object in script like this:<p>
<div class="fragment"><pre class="fragment">function foo()
{
    %obj = <span class="keyword">new</span> SampleObject(MySampleObject);
    echo(%obj.getName());
}
</pre></div><h2><a class="anchor" name="ConFields"></a><a name = "HeaderLink6"></a><a name = "HeaderLink6"></a><a name = "HeaderLink6"></a>Adding Class Member Fields</h2>
Data members of C++ classes can be accessed from within the scripting language.<p>
When the game starts, the console calls AbstractClassRep::initialize(), which assigns network IDs to classes, links class hierarchies, and initializes field data for each class. To do this, each class with accessible data members declares a static member function called initPersistFields(). This function calls the addField static member function for each data member of the class:
<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> SampleObject::initPersistFields()
{
    Parent::initPersistFields();  <span class="comment">// adds the parent class's fields as well.</span>
    addField(<span class="stringliteral">"someVariable"</span>, TypeS32, Offset(someVariable, SampleObject));
}
</pre>
</div><p>
The type must be properly specified, of course. The Offset macro is used to determine the relative address of the data member in the class. Once this is defined, scripts can use the member field of the object directly:<p>
<div class="fragment"><pre class="fragment">function bar()
{
    %obj = <span class="keyword">new</span> SampleObject(MySampleObject);
    %obj.someVariable = 100;
    echo(%obj.someVariable);
}
</pre></div><p>
Field types are declared in engine/console/consoleTypes.h. New console data types can be added by adding a type to consoleTypes.h and calling Con::registerType(typeId, typeSize, getDataFunc, setDataFunc). See engine/console/consoleTypes.cc for examples of how types are defined.
<h2><a class="anchor" name="ConDynamic"></a><a name = "HeaderLink7"></a><a name = "HeaderLink7"></a><a name = "HeaderLink7"></a>Dynamically Defined Fields</h2>
Member fields of objects can also be defined from within the script itself. For example:<p>
<div class="fragment"><pre class="fragment">function foo()
{
    %<span class="keywordtype">object</span> = <span class="keyword">new</span> SampleObject();
    %<span class="keywordtype">object</span>.scriptVariable = <span class="stringliteral">"Hello World!"</span>;
    echo(%<span class="keywordtype">object</span>.scriptVariable);
}
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Fields added in this way are only set and present on the instance on which they were set.</dd></dl>
<h2><a class="anchor" name="ConNamespace"></a><a name = "HeaderLink8"></a><a name = "HeaderLink8"></a><a name = "HeaderLink8"></a>Namespaces</h2>
Namespaces (engine/console/consoleInternal.h) are collections of class member functions. Every <a class="el" href="../Engine%20Reference/a01077.html" title="Base class for objects involved in the simulation.">SimObject</a> belongs to exactly one namespace. By default, an object belongs to the namespace that corresponds to its class - so an instance of <a class="el" href="../Engine%20Reference/a00336.html" title="Base class for game objects which use datablocks, networking, are editable, and need...">GameBase</a> will have the GameBase namespace. Each namespace has a parent, so methods can invoke parent class methods by calling Parent::function().
<p>
New namespaces (not class-based) can be added in the engine via the Con::linkNamespaces() function. Assigning the mNameSpace field of SimObject then assigns the new namespace to an object. For example, in GuiControl::onAdd(), if a control has a name its name is used as its namespace. This allows a named GUI control to have special behaviors.
<p>
The <a class="el" href="../Engine%20Reference/a00934.html">ScriptObject</a> class (defined in engine/console/scriptObject.cc) allows for the creation of "classes" within the scripting language:
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">new</span> ScriptObject(MyObject) {
    <span class="keyword">class </span>= Bar;
    superClass = Foo;
};

function Bar::doSomething(%<span class="keyword">this</span>)
{
    echo(<span class="stringliteral">"Hi!"</span>);
}

MyObject.doSomething();
&gt; Hi!

function Foo::doSomething(%<span class="keyword">this</span>)
{
    echo(<span class="stringliteral">"Hi! Foo"</span>);
}

function Bar::go(%<span class="keyword">this</span>)
{
    %<span class="keyword">this</span>.doSomething();
    Parent::doSomething(%<span class="keyword">this</span>);
}

MyObject.go();
&gt; Hi!
&gt; Hi! Foo
</pre>
</div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Every SimObject in the system can be addressed either by name or by ID. So in the example above, MyObject.go() searches the object dictionary for an object named MyObject and calls the go() method on that object.</dd>
</dl>
<h2><a class="anchor" name="ConPackage"></a><a name = "HeaderLink9"></a><a name = "HeaderLink9"></a><a name = "HeaderLink9"></a>Packages</h2>
Packages are collections of functions that can be enabled and disabled at runtime. Package functions can override (redefine) the behavior of existing functions in the global state or in packages that have been activated earlier. Prior versions of a function can then be accessed using "Parent". For example:<p>
<div class="fragment"><pre class="fragment">function foo()
{
    echo(<span class="stringliteral">"foo!"</span>);
}

<span class="keyword">package </span>SamplePackage
{

function foo()
{
    echo("Haha!");
    Parent::foo();
}

}

% foo();
foo!
% ActivatePackage(SamplePackage);
% foo();
Haha!
foo!
</pre></div><p>
Packages are useful for creating mods to games or for implementing specific game modes.<h2><a class="anchor" name="ConVariables"></a><a name = "HeaderLink10"></a><a name = "HeaderLink10"></a><a name = "HeaderLink10"></a>Variables</h2>
The console language supports global variables and local (function scoped) variables. Global variables are specified by a preceding $, and local variables by a % sign. Example:<p>
<div class="fragment"><pre class="fragment">$someGlobal = <span class="stringliteral">"This is some global."</span>;

function foo(%local1, %local2)
{
    %local3 = $someGlobal;
}

function bar(%local)
{
    <span class="comment">// You can also create a new global from within a function!</span>
    $alottaGlobal = %local @ <span class="stringliteral">" is."</span>;
}
</pre></div><h2><a class="anchor" name="ConArray"></a><a name = "HeaderLink11"></a><a name = "HeaderLink11"></a><a name = "HeaderLink11"></a>Arrays</h2>
The console language supports associative single- and multi-dimensional arrays. Arrays actually construct new variables with the names concatenated - so for example $array[10] is the same as $array10, while $array[3, 4] is the same as $array3_4. Strings can be used as array indexes as well: $array["foo"] = 100;. Array dimensions are separated with commas inside the brackets - $array[1, 0] = 10;<h2><a class="anchor" name="ConStringOp"></a><a name = "HeaderLink12"></a><a name = "HeaderLink12"></a><a name = "HeaderLink12"></a>Special String Operators</h2>
There are several special operators for strings in the scripting language:<ul>
<li><b>$=</b> Case insensitive string comparison. True if strings are equal.</li><li><b>!$=</b> Negative case insensitive string comparison. True if strings are not equal</li><li><b>@</b> String concatenation operator: "Hello " @ "World!" == "Hello World!"</li><li><b>TAB</b> String concatenation with a tab. "Hello" TAB "World!" == "Hello\tWorld!"</li><li><b>NL</b> String concatenation with a newline. "Hello" NL "World!" == "Hello\nWorld!"</li><li><b>SPC</b> String concatenation with a space. "Hello" SPC "World!" == "Hello World!"</li></ul>
<h2><a class="anchor" name="ConCompiler"></a><a name = "HeaderLink13"></a><a name = "HeaderLink13"></a><a name = "HeaderLink13"></a>Compiler</h2>
Scripts are executed in a two step process: First the script is compiled into a tokenized instruction stream, then the instruction stream is processed using the compiled evaluator.<h2><a class="anchor" name="ConDebugger"></a><a name = "HeaderLink14"></a><a name = "HeaderLink14"></a><a name = "HeaderLink14"></a>Debugger</h2>
The console supports remote debugging via another instance of Torque. In the game instance to be debugged, debugger port and password must be set using the dbgSetParameters(port, password); Then, in the instance to be used as the debugger, the GUIs and scripts in common/debugger/ must be loaded.
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../Engine%20Reference/a01137.html" title="Telnet debug service implementation.">TelnetDebugger</a> <a class="el" href="../Engine%20Reference/a02449.html#ad3a54ef5fb260160ec7493483246022" title="Hack to work around Microsoft VC&#39;s non-C++ compliance on variable scoping."></a> for more details on the debugger.</dd>
</dl>
<h2><a class="anchor" name="ConInterface"></a><a name = "HeaderLink15"></a><a name = "HeaderLink15"></a><a name = "HeaderLink15"></a>Interfacing with C++ Code</h2>
The C++ game and engine code can be called from the scripts as described above, and the game code can also call into script using the console execute and evaluate functions:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// simple execute of a console function using argv array:</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *execute(S32 argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[]);

<span class="comment">// simple execute of a console function, without stuffing an array</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *executef(S32 argc, ...);
   
<span class="comment">// execution of a method on a SimObject using argv array:</span>
<span class="comment">// first param is func name, second param MUST be empty</span>
<span class="comment">// also, MUST have at least those two params</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *execute(SimObject *, S32 argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[]);

<span class="comment">// execution of a method on a SimObject without stuffing an array</span>
<span class="comment">// first param is funcName, remaining params are args</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *executef(SimObject *, S32 argc, ...); 

<span class="comment">// evaluation of an arbitrary console command script:</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *evaluate(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">string</span>, <span class="keywordtype">bool</span> echo, <span class="keyword">const</span> <span class="keywordtype">char</span> *fileName);

<span class="comment">// evaluation of a formatted (ala printf) command string:</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *evaluatef(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">string</span>, ...);
</pre>
</div><p>
Examples:<p>
<div class="fragment"><pre class="fragment">SimObject *mySimObject = <span class="keyword">new</span> SimObject;

Con::executef(mySimObject, 4, <span class="stringliteral">"doSomething"</span>, Con::getIntArg(20), <span class="stringliteral">"Bye"</span>, <span class="stringliteral">"Hi"</span>);
Con::evaluatef(<span class="stringliteral">"mySimObject.doSomething(%d,\"%s\",\"%s\");"</span>, 20, <span class="stringliteral">"Bye"</span>, <span class="stringliteral">"Hi"</span>);

<span class="keyword">const</span> <span class="keywordtype">char</span> *argv[5];
argv[0] = <span class="stringliteral">"doSomething"</span>;
argv[1] = NULL;
argv[2] = Con::getIntArg(20);
argv[3] = <span class="stringliteral">"Bye"</span>;
argv[4] = <span class="stringliteral">"Hi"</span>;

Con::execute(mySimObject, 5, argv);
</pre>
</div><p>
The functions Con::getIntArg, Con::getFloatArg and Con::getArgBuffer(size) are used to allocate on the console stack string variables that will be passed into the next console function called. This allows the console to avoid copying some data.   </td>
</tr>
</table>

</div>
<div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>

<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/Console.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:10 GMT -->
</html>