<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/WorkingWithTorque.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD><SCRIPT SRC="../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../index.html";</SCRIPT><link href="../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 16;
   parent.leftFrame.expandToItem('tree2', 'doc16');
   var element = parent.leftFrame.document.getElementById('doc16');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Working With Torque</title>
<link href="torque.css" rel="stylesheet" type="text/css">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066">
<div align="center">

<table width=700 cellspacing=0 cellpadding=10 border=0 bgcolor="#ffffff" summary="">
<tr><td>


<!-- Generated by Doxygen 1.5.4 -->
<h1><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a>Working With Torque</h1>
<p>

<h2><a class="anchor" name="Intro_WWT_GameEngine"></a><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a>Torque as a Game Engine</h2>
<p>Game engines are designed to handle and manage a large majority of the low level requirements of complex games. They serve as an integrated environment for your games to operate within, managing many of the complex but fundamentally important requirements of any game, from basic FPS's all the way to complex RPGS. Just a few of the major systems and capabilities Torque manages for you include:</p>
<ul>
<li>Memory Management</li>
<li>Object Instantiation, Referencing, Messaging, and Deletion</li>
<li>Resource Management</li>
<li>Graphics Hardware Abstraction</li>
<li>Sound Hardware Abstraction</li>
<li>Streaming, Event, and Client/Server Synchronization Networking</li>
<li>much, much more!</li></ul>
<p>In addition to handling so many of the boring, low level details, Torque also provides reference implementations for more complex game structures, with many example Game Projects for study and use. It's important to understand however that these examples are for reference--every game will require additional development to implement game specific requirements, and it is fully expected that you will need to learn the underlying operation and theory of the engine to accomplish your goals.</p>

<h2><a class="anchor" name="Intro_WWT_GeneralOps"></a><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a>Using a Game Engine</h2>
<p>One of the things that confuses many people who have made games before, but not worked within an engine framework, is that many of the low level systems appear hidden, or hard to find for beginners. it's important to realize that is intentional! The biggest benefit of using a game engine instead of implementing everything needed from scratch, or from a hodge podge of external libraries, is that you can avoid having to worry about all of the hundreds, if not thousands of details that are critical, but also distract you from focusing on making your game--after all, you are here to implement your dream game, and having to worry about all the details that ultimately have nothing to do with your vision (but are required to meet your vision) isn't something you want to worry about.</p>
<p>Later on in this document we will be giving introductions to some of the underlying systems, but early on in your game development process, it's best to focus on learning to work with Torque, instead of trying to adapt Torque to your previous experiences. For example, if the first thing that comes to mind when getting started is "Where's the Main() loop?", then you probably want to reset your approach!</p>
<p>Torque is designed to provide you abstracted access to hardware, memory, input/output devices, and many other aspects of game development, isolating you from the low level details so you can focus on your game. We'll discuss concepts such as Event Driven Simulations, Interfacing TorqueScript with C++, and general game engine approaches in the sections below.</p>
<h3><a class="anchor" name="Intro_EventDrivenSimulation"></a><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a>Working with an Event Driven Simulation</h3>
<p>Sounds scary, but once you become familiar with the concept, event driven simulations are very intuitive ways to make games. The premise behind this concept is that within our game world, everything exists as an object, and these objects interact over time with each other, and the players to make things happen.</p>
<p>It's very much like the real world if you think about it--when we wake up in the morning, it's probably due to an alarm going off (an event), which triggers an action--we reach over and hit the snooze button (an input). The input of hitting the snooze button in turn is an event to the "alarm clock" object, and it reacts to that event by turning off the alarm noise and waiting for 9 minutes to trigger another alarm event.</p>
<p>This concept is how we program with Torque--we implement a set of objects, and define events that can occur for those objects, and then implement handlers (called Callbacks) to manage the events as they come.</p>
<p>In effect, we give up direct control over the game itself, and instead design each object to interact and react with the objects around them, as well as inputs from the players, as well as time passing within our world. This style fits very well within the concepts of Object Oriented Programming, and allows us to achieve very complex interactions very easily.</p>

<h3><a class="anchor" name="Intro_GameLayers"></a><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a>Layers of Game Development</h3>
<p>Torque is designed to operate at 3 different levels:</p>
<ul>
<li><b>Systems Management</b>--the engine taking care of business for you</li>
<li><b>Object Implementation</b>--code you have written (or derived from the Game Examples) to implement capabilities for objects</li>
<li><b>Gamplay Implementation</b>--code that uses capabilities you have implemented to describe game play</li>
</ul>
<p>At the systems management level, Torque takes care of all the work for you--that's all the hundreds of thousands of lines of source code that operates in the background, saving you months of development effort. As a Game Developer, you should probably not need to deal with the Systems Management layer very much at all.</p>
<p>However, even though the various Game Examples demonstrate many complex and cool capabilities, Torque does not do everything that you will want your game to do, so you will need to hunker down and get to work! This is where the Object Implementation layer comes in--you will be utilizing C++ (or in some cases, skipping directly to the Gameplay Implementation layer if the example games provide exactly what you need already) to describe and implement how your objects interact with the world.</p>
<p>Finally, the Gamplay Implementation layer is where you will be implementing how your game works--from spawning the player to reacting to collisions, to keeping track of teams and score, this layer is where you create your world.</p>

<h3><a class="anchor" name="Intro_Networking"></a><a name = "HeaderLink5"></a><a name = "HeaderLink5"></a>The Zen of Networking</h3>
<p>Network architecture is an incredibly complex subject, and Torque is known world wide for having one of the best networking architectures in game development. This is a great thing for aspiring and experienced game developers alike--but it adds a layer of complexity that can cause confusion and frustration for anyone first getting their feet wet with the engine, so let's discuss a few key principles of a networked engine architecture:</p>
<h4><a class="anchor" name="Intro_ClientServer"></a><a name = "HeaderLink6"></a><a name = "HeaderLink6"></a>I'm a Client, You're the Server</h4>
<p>There is one key principle to understand when working with Torque:  No matter what type of game you are making, the stock engine expects that there will <b>always</b> be both a client and a server--even on a single computer!</p>
<p>This is a very powerful thing when it comes to game development--when a game is implemented correctly (keeping this principle in mind) with Torque, it is pretty much automatically multi-player ready! That comes at a price in some ways however in both development complexity and footprint, but for a very large majority of games today, it's well worth the extra effort.</p>
<p>There are dozens of reasons and benefits behind why this is a good architecture for a game engine--here are just a few:</p>
<ul>
<li>Automatic Multi-Player capability</li>
<li>Built in game security (anti-hack/anti-cheat)</li>
<li>Flexible Deployment</li>
<li>Adaptable Gameplay</li>
</ul>
<p>As mentioned however, there are some costs associated with this architecture, including:</p>
<ul>
<li>Larger game footprint for single player games</li>
<li>Coupled object implementations (physics and networking tightly tied together)</li>
<li>Somewhat more complex implementations for certain tasks</li>
</ul>
<h4><a class="anchor" name="Intro_ClientServerModes"></a><a name = "HeaderLink7"></a><a name = "HeaderLink7"></a>Network Architecture Modes</h4>
<p>There are three primary modes of Client/Server Interaction:</p>
<ul>
<li><b>Single Player</b>--the server and the client exist in a single executable, sharing memory</li>
<li><b>Hosted Multi-Player</b>--the server shares an executable (as above) with one client, and other clients connect via a network</li>
<li><b>Dedicated Server</b>--the server stands alone, and all clients connect via a network</li>
</ul>
<p>Each of the three modes listed above have different primary uses, and as your game evolves you will select the most appropriate mode.</p>
<h4><a class="anchor" name="Intro_ClientServerRoles"></a><a name = "HeaderLink8"></a><a name = "HeaderLink8"></a>Who does what, when?</h4>
<p>Since all games developed with Torque will have both a client and a server, it's important to understand what each is responsible for, and where you should implement a particular capability for your game. Whenever you are thinking about an aspect of your project, you should always be asking yourself, "Should that happen on the client, or the server?"--and in the situations where the other side of the architecture needs to be aware of something happening elsewhere, how to communicate between the two.</p>
<ul>
<li><b>Server Roles</b>--Anything that affects the game world should happen on the server, and communicated to clients as appropriate</li>
<ul>
<li>Physics</li>
<li>Collision</li>
<li>World Object Manipulation</li>
<li>World State Management</li>
</ul>
<li><b>Client Roles</b>--Interactions with the player should happen on the client, and communicated with the server</li>
<ul>
<li>Input</li>
<li>Rendering</li>
<li>Sound</li>
<li>Graphical User Information</li>
</ul>
</ul>
<p>Torque provides a variety of ways to communicate between the server and the client (and the reverse), including automated client synchronization, real time streaming networking, and a variety of network events all wrapped by a UDP based network protocol.</p>

<h3><a class="anchor" name="Intro_Scripting"></a><a name = "HeaderLink9"></a><a name = "HeaderLink9"></a>To script or not to script, that is the question...</h3>
<p>Torque provides two primary ways of implementation for your game development, and in many cases the choice of implementation strategy can be confusing. In general, Object Implementation (the second layer) is performed in C++, while Gameplay Implementation (the third layer) is performed in TorqueScript, but this is only a rule of thumb, and different games (and different game developers) will require different strategies.</p>
<p>Generally speaking, TorqueScript is an excellent choice for most Gameplay implementation, and can also be used for initial prototyping of most Object Implementation. Generally speaking however, before you release a game to the public, you will want to re-implement your Object Implementation in C++ for speed and efficiency.</p>
</td>
</tr>
</table>

</div>
<div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>

<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/WorkingWithTorque.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:08 GMT -->
</html>