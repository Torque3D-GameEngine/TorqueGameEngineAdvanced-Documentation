<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/Networking.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD><SCRIPT SRC="../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../index.html";</SCRIPT><link href="../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 11;
   parent.leftFrame.expandToItem('tree2', 'doc11');
   var element = parent.leftFrame.document.getElementById('doc11');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Torque Networking</title>
<link href="torque.css" rel="stylesheet" type="text/css">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066">
<div align="center">

<table width=700 cellspacing=0 cellpadding=10 border=0 bgcolor="#ffffff" summary="">
<tr><td>


<!-- Generated by Doxygen 1.5.4 -->
<h1><a class="anchor" name="Networking"></a><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a>Networking </h1><h2><a class="anchor" name="NetOver"></a><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a>Overview</h2>
<p>Torque was designed from the foundations up to offer robust client/server networked simulations. Performance over the internet drove the design for the networking model. Torque attempts to deal with three fundamental problems of network simulation programming - limited bandwidth, packet loss and latency. For a more detailed, if somewhat outdated, description of the Torque network architecture, see "The Tribes II Engine Networking Model" paper by Tim Gift and Mark Frohnmayer and the accompanying PowerPoint slides in the Torque documentation area on GarageGames.com.</p>
<p>An instance of Torque can be set up as a dedicated server, a client, or both a client and a server. If the game is a client AND a server, it still behaves as a client connected to a server - instead of using the network, however, the <a class="el" href="../Engine%20Reference/a00724.html" title="Torque network connection.">NetConnection</a> object has a short-circuit link to another NetConnection object in the same application instance.</p>
<p>Bandwidth is a problem because in the large, open environments that Torque allows, and with the large number of clients that your game supports (depending on amount of data sent per client, game world complexity, and available bandwidth), potentially many different objects can be moving and updating at once. The Torque uses three main strategies to maximize available bandwidth. First, it prioritizes data, sending updates to what is most "important" to a client at a greater frequency than it updates data that is less important. Second, it sends only data that is necessary - using the <a class="el" href="../Engine%20Reference/a00102.html">BitStream</a> class, only the absolute minimum number of bits needed for a given piece of data will be sent. Also, when object state changes, Torque only sends the part of the object state that changed. Last, Torque caches common strings (<a class="el" href="../Engine%20Reference/a00734.html">NetStringTable</a>) and data (<a class="el" href="../Engine%20Reference/a01065.html" title="Root DataBlock class.">SimDataBlock</a>) so that they only need to be transmitted once.</p>
<p>Packet loss is a problem because the information in lost data packets must somehow be retransmitted, yet in many cases the data in the dropped packet, if resent directly, will be stale by the time it gets to the client - for example, suppose that packet 1 contains a position update for a player and packet 2 contains a more recent position update for that same player. If packet 1 is dropped but packet 2 makes it across the engine shouldn't resend the data that was in packet 1 - it is older than the version that was received by the client. In order to minimize data that gets resent unnecessarily, the engine classifies data into four groups:</p>
<ul>
<li><b>Unguaranteed Data</b> (<a class="el" href="../Engine%20Reference/a00729.html" title="An event to be sent over the network.">NetEvent</a>) - if this data is lost, don't re-transmit it. An example of this type of data could be real-time voice traffic - by the time it is resent subsequent voice segments will already have played.</li><li><b>Guaranteed Data</b> (NetEvent) - if this data is lost, resend it. Chat messages, messages for players joining and leaving the game and mission end messages are all examples of guaranteed data.</li>
<li><b>Most-Recent State Data</b> (<a class="el" href="../Engine%20Reference/a00732.html" title="Superclass for ghostable networked objects.">NetObject</a>) - Only the most current version of the data is important - if an update is lost, send the current state, unless it has been sent already.</li><li><b>Guaranteed Quickest Data</b> (<a class="el" href="../Engine%20Reference/a00709.html">Move</a>) - critical data that must get through as soon as possible.</li></ul>
<p>Latency is a problem in the simulation because the network delay in information transfer (which, for modems, can be up to a quarter of a second or more) makes the client's view of the world perpetually out-of-sync with the server. Twitch FPS games, for which Torque was initially designed, require instant control response in order to feel anything but sluggish. Also, fast moving objects can be difficult for highly latent players to hit. In order to solve these problems Torque employs several strategies:</p>
<ul>
<li><b>Interpolation</b> is used to smoothly move an object from where the client thinks it is to where the server says it is.</li><li><b>Extrapolation</b> is used to guess where the object is going based on its state and rules of movement.</li><li><b>Prediction</b> is used to form an educated guess about where an object is going based on rules of movement and client input.</li></ul>
<p>The network architecture is layered: at the bottom is the platform layer, above that the notify protocol layer, followed by the NetConnection object and event management layer. The following sections explain how each layer addresses some or all of the fundamental network simulation problems.
<h2><a class="anchor" name="NetPlatform"></p></a><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a>Platform Networking Layer (TCP/UDP)</h2>
<p>The platform library provides the interface between the game engine and the OS dependent network functionality. The platform library's <a class="el" href="../Engine%20Reference/a00721.html" title="Platform-specific network operations.">Net</a> interface contains functions for opening reliable and unreliable communication sockets, converting between string and numeric network addresses and sending and receiving data.</p>
<p>Net::openPort() opens an unreliable socket, of which only one is allowed per application instance. Net::sendto() sends an unreliable datagram to the specified <a class="el" href="../Engine%20Reference/a00722.html" title="Generic network address.">NetAddress</a>. Net::openListenPort() opens a reliable socket for incoming TCP connections. Net::openConnectTo() begins the process of asynchronously connecting to a remote TCP socket. Net::sendtoSocket() sends data over an established TCP connection. Net::process() processes the platform network layer, possibly generating network related events that are then posted into the simulation via GameInterface::processEvent().</p>
</p>Torque also has some good debugging capabilities. The DEBUG_NET and DEBUG_LOG() macros are used to control debug output from the networking code. A full explanation of this functionality is beyond the scope of this overview; however, searching the source for instances of DEBUG_LOG should get you on the way to understanding this part of Torque.
<h2><a class="anchor" name="NetProtocol"></p></a><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a>Connection Protocol</h2>
<h3><a class="anchor" name="NetConnNegotiation"></a><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a>Connection Negotiation</h3>
<p>The negotiation of a game network connection is not actually a part of the network class tree in the Torque - instead a set of functions, declared in engine/game/netDispatch.cc perform this service. The function DemoGame::processPacketReceiveEvent() is the main dispatch function for incoming network packets.</p>
<p>The first step of the connection process is the console function connect(), which initiates a connection attempt by sending a connect challenge request packet to the server from sendConnectChallengeRequest().</p>
<p>The server, in handleConnectChallengeRequest(), may issue the client a connect challenge response, which the client will process in handleConnectChallengeResponse. The client will in turn issue a connect request (sendConnectRequest) with the challenge information it received from the server. The server processes this message in handleConnectRequest. If the server decides to accept the request, it issues a sendConnectAccept back to the client and constructs a NetConnection object on the server to handle that client. The client, in handleConnectAccept creates a complementary NetConnection object to manage the client side of the connection. The dispatchCheckTimeouts function periodically checks if a connection request or challenge has been waiting too long and reissues the request if it has.
<h3><a class="anchor" name="NetConnProtocol"></p></a><a name = "HeaderLink5"></a><a name = "HeaderLink5"></a><a name = "HeaderLink5"></a>Once We're Connected...</h3>
<p>Once a connection has been established, the function of the <a class="el" href="../Engine%20Reference/a00175.html" title="The base class for Torque&#39;s networking protocol.">ConnectionProtocol</a> class is to provide a common low-level mechanism for supporting the delivery of the four fundamental types of network data in the Torque. The ConnectionProtocol abstract base class implements a sliding window connected message stream over an unreliable transport (UDP). Rather than supporting guaranteed messages directly, the ConnectionProtocol class implements a notify protocol. Each packet sent is prepended with a message header containing tracking information, including what packets the other end of the connection has received or were dropped in transit. When a ConnectionProtocol instance determines that a packet it sent has been either received or dropped, it calls ConnectionProtocol::handleNotify(). Notifies are always delivered in the order packets were sent - so for every packet sent through a ConnectionProtocol object, eventually a notification of successful (ack) or unsuccessful (nack) delivery will be executed.</p>
<p>Because the base network protocol exports the inherently unreliable nature of the network to the simulation, at a higher level Torque can directly support different types of data guarantee: for unguaranteed data, if it is nacked, there is no need to resend it. For guaranteed data, if it is nacked, the engine queues it up for resend (NetConnection::eventPacketDropped()). If the data is most recent state data and the packet is nacked and that object's state hasn't been subsequently changed and resent, queue the data up for resend (NetConnection::ghostPacketDropped()). If the data is set for quickest possible delivery, continue sending the data with every packet until a packet containing the data is acked (GameConnection::readPacket()).
<h2><a class="anchor" name="NetConnection"></p></a><a name = "HeaderLink6"></a><a name = "HeaderLink6"></a><a name = "HeaderLink6"></a>NetConnection</h2>
The NetConnection class is derivative from both <a class="el" href="../Engine%20Reference/a01072.html" title="A group of SimObjects.">SimGroup</a> and ConnectionProtocol, and is responsible for managing the data streaming between client and server. The NetEvent class encapsulates the guaranteed and unguaranteed message delivery types and the ghost management portion of the NetConnection class handles state updates of world objects from server to client. The Torque example game-specific subclass of NetConnection is <a class="el" href="../Engine%20Reference/a00338.html">GameConnection</a> and handles transmission of game specific data such as player moves.
<p>
The NetConnection class sends packets of a fixed size in a regular stream between the client and server. When a message is posted for transmission, it is aggregated with other messages and sent based on the packet rate and packet size settings for that connection.
<h2><a class="anchor" name="NetBitstream"></a><a name = "HeaderLink7"></a><a name = "HeaderLink7"></a><a name = "HeaderLink7"></a>The BitStream</h2>
<a class="el" href="../Engine%20Reference/a00102.html">BitStream</a> is a utility class used to pack data for transmission. BitStream has methods for reading and writing variable-sized integers, floats, vectors, Huffman-coded strings and bits.
<p>
When a NetConnection instance determines it is ready to send a packet across the network (NetConnection::checkPacketSend()), it allocates a BitStream and calls NetConnection::writePacket() with the stream. When a packet is received it is processed through the corresponding NetConnection::readPacket() function.
<h2><a class="anchor" name="NetEvents"></a><a name = "HeaderLink8"></a><a name = "HeaderLink8"></a><a name = "HeaderLink8"></a>Network Events</h2>
The <a class="el" href="../Engine%20Reference/a00729.html" title="An event to be sent over the network.">NetEvent</a> class provides a foundation for guaranteed, guaranteed ordered and unguaranteed message transmission. NetEvent uses the same class instance creation mechanism as the console, but rather than instantiating by name, NetEvents use a class ID, which was assigned when the console initializes.
<p>
If the pack and unpack methods don't match in terms of what they read and write into the stream, serious network errors can occur. The client and server should gracefully disconnect in these cases, but the errors themselves can be very difficult to track down. If the DEBUG_NET macro is defined, a special key will be written into the packet stream after each event and object update, and the system will assert immediately when it detects that this problem has occurred.<h2><a class="anchor" name="NetGhost"></a><a name = "HeaderLink9"></a><a name = "HeaderLink9"></a><a name = "HeaderLink9"></a>Network Ghosts and Scoping</h2>
The <a class="el" href="../Engine%20Reference/a00732.html" title="Superclass for ghostable networked objects.">NetObject</a> class is a derivative of SimObject that can replicate (ghost) itself across a network connection. All world object classes are subclassed from NetObject (the superclass of SceneObject). In order to best utilize the available bandwidth, the NetConnection attempts to determine which objects are "interesting" to each client - and among those objects, which ones are most important. If an object is interesting to a client it is said to be "in scope" - for example, a visible enemy to a player in a first person shooter would be in scope.
<p>
Each NetConnection object maintains a scoping object - responsible for determining which objects are in scope for that client. Before the NetConnection writes ghost update information into each packet in NetConnection::ghostWritePacket(), it calls the scope object's onCameraScopeQuery() function which performs two services: first, it determines which objects are "in scope" for that client and calls NetConnection::objectInScope for each object on that client. Second, the onCameraScopeQuery() call fills in the CameraScopeQuery structure which is then used to determine the priority of object updates.
<p>
The default NetObject::onCameraScopeQuery() function scopes everything in the world, but the Torque game example overrides this in ShapeBase::onCameraScopeQuery(). <a class="el" href="../Engine%20Reference/a01034.html" title="ShapeBase is the renderable shape from which most of the scriptable objects are derived...">ShapeBase</a> calls the server SceneGraph::scopeScene() function to traverse the scene from the client's point of view and scope all potentially visible objects. Each scoped object that needs to be updated is then prioritized based on the return value from the NetObject::getUpdatePriority() function, which by default returns a constant value. This function is overridden in ShapeBase::getUpdatePriority() to take into account the object's distance from the camera, its velocity perpendicular to the view vector, and other factors.
<p>
Rather than always sending the full state of the object each time it is updated across the network, the Torque supports only sending portions of the object's state that have changed. To facilitate this, each NetObject can specify up to 32 independent sub-states that can be modified individually. For example, a player object might have a movement state, detailing its position and velocity, a damage state, detailing its damage level and hit locations, and an animation state, signifying what animation, if any, the player is performing.
<p>
Each state data group is assigned a bit position in the class. When an object's state changes, the object notifies the network system with the NetObject::setMaskBits function. When the object is to be written into a packet in NetObject::packUpdate, the object's current state mask is passed in. The object's state mask is NOT written into the packet directly - it is the responsibility of the pack function to accurately encode which states are updated.
<p>
Initially an object's state mask is set to all 1's - signifying that all the object's states need to be updated.<h2><a class="anchor" name="NetGameConnection"></a><a name = "HeaderLink10"></a><a name = "HeaderLink10"></a><a name = "HeaderLink10"></a>GameConnection, Moves and the Control Object</h2>
<a class="el" href="../Engine%20Reference/a00338.html">GameConnection</a> is the game-specific subclass of NetConnection. Applications can subclass NetConnection to directly write and read data from packets, as well as hook into the notify mechanism. The NetConnection::allocNotify() function is called at the beginning of a packet write and is used to allocate a NetConnection::PacketNotify structure. This structure is used to store information about the data written into the network packet. When the packet is either acked or nacked, this notify structure is passed into the NetConnection::handleNotify() function. Subclasses of NetConnection can subclass the PacketNotify structure and override the allocNotify method to add custom data to the packet tracking record.
<p>
The GameConnection in the Torque example introduces the concept of the control object. The control object is simply the object that the client associated with that network connection controls. By default in the example the control object is an instance of the <a class="el" href="../Engine%20Reference/a00795.html">Player</a> class, but can also be an instance of <a class="el" href="../Engine%20Reference/a00117.html" title="Implements a basic camera object.">Camera</a> (when editing the mission, for example).
<p>
The Torque example uses a model in which the server is the authoritative master of the simulation. To prevent clients from cheating, the server simulates all player moves and then tells the client where his player is in the world. This model, while secure, can have problems - if the network latency is high, this round-trip time can give the player a very noticeable sense of movement lag. To correct this problem, the example uses a form of prediction - it simulates the movement of the control object on the client and on the server both. This way the client doesn't need to wait for round-trip verification of his moves - only in the case of a force acting on the control object on the server that doesn't exist on the client does the client's position need to be forcefully changed.
<p>
To support this, all control objects (derivative of ShapeBase) must supply a writePacketData() and readPacketData() function that send enough data to accurately simulate the object on the client. These functions are only called for the current control object, and only when the server can determine that the client's simulation is somehow out of sync with the server. This occurs usually if the client is affected by a force not present on the server (like an interpolating object) or if the server object is affected by a server only force (such as the impulse from an explosion).
<p>
The <a class="el" href="../Engine%20Reference/a00709.html">Move</a> structure is a 32 millisecond snapshot of player input, containing x, y, and z positional and rotational changes as well as trigger state changes. When time passes in the simulation moves are collected (depending on how much time passes), and applied to the current control object on the client. The same moves are then packed over to the server in GameConnection::writePacket(), for processing on the server's version of the control object.
<h2><a class="anchor" name="NetDatablocks"></a><a name = "HeaderLink11"></a><a name = "HeaderLink11"></a><a name = "HeaderLink11"></a>Datablocks</h2>
<p></p>Datablocks (ie, subclasses of <a class="el" href="../Engine%20Reference/a01065.html" title="Root DataBlock class.">SimDataBlock</a>) are used in the network system to store common instance data for objects. For example, a datablock may store animation data, model information, physical movement properties, etc, all of which are shared across a set of common objects. All declared datablocks are sent to clients upon connection as guaranteed events (<a class="el" href="../Engine%20Reference/a01066.html">SimDataBlockEvent</a>), and can then be referenced and sent as part of the initial ghost update. An advantage of datablocks is that they are declared only on the server, so mods to the game can be created without forcing the client to downloading any script data.<h2><a class="anchor" name="NetStringTable"></p></a><a name = "HeaderLink12"></a><a name = "HeaderLink12"></a><a name = "HeaderLink12"></a>NetStringTable</h2>
The <a class="el" href="../Engine%20Reference/a00734.html">NetStringTable</a> class manages string data across connections. Every tagged string in the console - those enclosed by single quotes ('), will be sent across a connection only a single time. Every subsequent time that string is sent, an integer tag is substituted for the actual string data. Strings like player names can be added with the addTaggedString console function and removed with the removeTaggedString console function.<h2><a class="anchor" name="NetConsole"></a><a name = "HeaderLink13"></a><a name = "HeaderLink13"></a><a name = "HeaderLink13"></a>Network Console Commands</h2>
There are two remote procedure call network console commands - commandToServer and commandToClient. The commandToServer function takes the form: commandToServer(functionNameTag, arg1, arg2, arg3, ... ), where functionNameTag is some string tag. This call is converted into a RemoteCommandEvent and set across to the server. Once there the server calls the local script function serverCmdXXX(clientId, arg1, arg2, arg3, ... ), where XXX is the text of the string tag. The commandToClient function takes the form: commandToClient(clientId, functionNameTag, arg1, arg2, arg3, ... ) where the clientId argument is the object id of the connection object to send to.
<p>
The commandTo* functions perform string argument substitution automatically using the in-string % modifier. For example:<p>
<div class="fragment"><pre class="fragment">commandToClient('EchoMessage', 
                'This %1 guy is super %2', 
                'Got Milk?', 
                'slow at writing documentation');
</pre></div><p>
is executed on the client as:<p>
<div class="fragment"><pre class="fragment"> function clientCmdEchoMessage(%message, %a1, %a2, %a3, %a4)
{
    <span class="comment">// tagged strings must be detagged in order to be displayed.</span>
    echo(detag(%message));
    echo(<span class="stringliteral">"a1 = "</span> @ detag(%a1));
    echo(<span class="stringliteral">"a2 = "</span> @ detag(%a2));
    echo(<span class="stringliteral">"a3 = "</span> @ detag(%a3));
    echo(<span class="stringliteral">"a4 = "</span> @ detag(%a4));
}
</pre></div><p>
and would echo: <div class="fragment"><pre class="fragment">This Got Milk? guy is super slow at writing documentation
a1 = Got Milk?
a2 = slow at writing documentation
a3 =
a4 =
</pre></div><p>
The string substitution number (after the %) refers to the argument position n spaces after the current argument:<p>
<div class="fragment"><pre class="fragment">CommandToClient('EchoMessage', 
                '%1 is a good %2 <span class="keywordflow">for</span> %3', 
                '%1 the good %2', 
                'Role Model', 
                'SuperDood %1', 
                'the dude of super');
</pre></div><p>
Would echo:<p>
<div class="fragment"><pre class="fragment">Role Model the good SuperDood the dude of super is a good Role Model 
<span class="keywordflow">for</span> SuperDood the dude of super
A1 = Role Model the good SuperDood the dude of super
A2 = Role Model
A3 = SuperDood the dude of super
A4 = the dude of super
</pre></div><p>
This functionality is especially useful for status and game messages coming from the server, because each text message compresses into just a small array of tag identifiers.   </td>
</tr>
</table>

</div>
<div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>

<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Overview/Networking.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:36:08 GMT -->
</html>