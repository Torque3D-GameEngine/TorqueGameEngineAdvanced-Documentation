<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Reference/a03021.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:40:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD><SCRIPT SRC="../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../index.html";</SCRIPT><link href="../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 1934;
   parent.leftFrame.expandToItem('tree2', 'doc1934');
   var element = parent.leftFrame.document.getElementById('doc1934');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><SCRIPT SRC="../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../index.html";</SCRIPT><link href="../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 1934;
   parent.leftFrame.expandToItem('tree2', 'doc1934');
   var element = parent.leftFrame.document.getElementById('doc1934');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGEA: GGConnectInterface::GameInterface Class Reference</title>
<link href="torque.css" rel="stylesheet" type="text/css">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  id = "BODYID" onLoad = "initComponent()"  bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066">
<div align="center">

<table width=700 cellspacing=0 cellpadding=10 border=0 bgcolor="#ffffff" summary="">
<tr><td>


<!-- Generated by Doxygen 1.4.7 -->
<div class="nav">
<a class="el" href="a04908.html">GGConnectInterface</a>::<a class="el" href="a03021.html">GameInterface</a></div>
<h1><a name = "HeaderLink0"></a><a name = "HeaderLink0"></a>GGConnectInterface::GameInterface Class Reference</h1><!-- doxytag: class="GGConnectInterface::GameInterface" --><code>#include &lt;GameInterface.h&gt;</code>
<p>
<a href="a00581.html">List of all members.</a><hr><a name="_details"></a><h2><a name = "HeaderLink1"></a><a name = "HeaderLink1"></a>Detailed Description</h2>
<a class="el" href="a03021.html">GameInterface</a> is an abstract interface that games should implement if they want to use the <a class="el" href="a04908.html">GGConnectInterface</a> helper code to communicate with the GGConnect framework. 
<p>
The <a class="el" href="a04908.html">GGConnectInterface</a> handles all over the GGConnect boiler-plate code, your <a class="el" href="a03021.html">GameInterface</a> object should just handle game-specific logic. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2><a name = "HeaderLink2"></a><a name = "HeaderLink2"></a>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#828808a6619756a1cd79deefabbdde82">GameReady</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GameReady is called when the game wants to signal that it is fully ready to process commands from the browser.  <a href="#828808a6619756a1cd79deefabbdde82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#b3104f564837f8a7f7362b6d4f7c7a08">GameInit</a> (const char *videoMode, <a class="el" href="a04954.html">bool</a> dedicated)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GameInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.init</a> RPC by the browser.  <a href="#b3104f564837f8a7f7362b6d4f7c7a08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#8b8ea0685e7410f2de372e0b0c2e8162">GameShutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GameInit is called when the game is sent the <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.shutdown</a> RPC by the browser.  <a href="#8b8ea0685e7410f2de372e0b0c2e8162"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#513ae78e91d2900697816eec46a05cf1">BlurSession</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BlurSession is called when the game is trying to be blurred (paused).  <a href="#513ae78e91d2900697816eec46a05cf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#d83341cfaaefa17f5d7524061df46850">FocusSession</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FocusSession is called when the game wants to focus (unpause).  <a href="#d83341cfaaefa17f5d7524061df46850"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#521263736a5029d33acde8b2f3676504">SetFocus</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GGC framework will call this method when your game should grab keyboard and mouse focus.  <a href="#521263736a5029d33acde8b2f3676504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#d43572b7b1673b93872b5ac82abcdd4c">FullscreenOn</a> (const char *videoMode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FullscreenOn is called when the fullscreen preference is turned on.  <a href="#d43572b7b1673b93872b5ac82abcdd4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#2d74e0cbe58326d2e3a2856d60b74059">FullscreenOff</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">FullscreenOff is called when the fullscreen preference is turned off.  <a href="#2d74e0cbe58326d2e3a2856d60b74059"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#731588ff5e672fa13534a80fe693341f">DoFullscreen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DoFullscreen is called when the game should begin displaying fullscreen.  <a href="#731588ff5e672fa13534a80fe693341f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#1f9aa7948539a93e9b185f4c7cff8d53">DoWindowed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DoWindowed is called when the game should stop displaying fullscreen.  <a href="#1f9aa7948539a93e9b185f4c7cff8d53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#a7b10eae2c9a7b9200d76e5280df7f37">RestoreWindow</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RestoreWindow is called to "maximize" a fullscreen game.  <a href="#a7b10eae2c9a7b9200d76e5280df7f37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#824549320047e09788f5ffa62dc1b4cc">MinimizeWindow</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MinimzeWindow is called to minimize a fullscreen game.  <a href="#824549320047e09788f5ffa62dc1b4cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#43511307559ff761b620b449343c9716">WidgetLoad</a> (const char *widgetName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WidgetLoad is called by the browser to request loading of a widget.  <a href="#43511307559ff761b620b449343c9716"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#9a4883e7b4936946b7d37e1cc00d015e">WidgetStart</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WidgetStart is called by the game to indicate the widget is ready for display.  <a href="#9a4883e7b4936946b7d37e1cc00d015e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#b6008f6c4869fddc01ce4da3cccc6c22">WidgetSave</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WidgetSave is called by the game or browser to save settings in a widget.  <a href="#b6008f6c4869fddc01ce4da3cccc6c22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#85fd22ee7dd3f254353bc8caeb117dc4">WidgetCancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WidgetCancel is called by the game or browser to cancel a widget.  <a href="#85fd22ee7dd3f254353bc8caeb117dc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#3b5b3ad877febe943a7d2e536f33f15c">WidgetClose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WidgetClose is called by the browser when it is safe to stop rendering the widget.  <a href="#3b5b3ad877febe943a7d2e536f33f15c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#09a676861664b6632dae23794a3a847b">ShowGameMenu</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show the in-game menu.  <a href="#09a676861664b6632dae23794a3a847b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#11d39f0bf6fbdc324d487d4947898185">HideGameMenu</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hide the in-game menu.  <a href="#11d39f0bf6fbdc324d487d4947898185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#bd1c1654b51347ec06f2387eec43df51">GameMenuHidden</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies the game that the in-game menu was hidden.  <a href="#bd1c1654b51347ec06f2387eec43df51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#290806e980dee86ed4412bdc52f7bced">SessionQuit</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#a6e390bc21b27075991247e5fe8f0547">SessionOver</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#9dd63e91349a811b91446f31b3ed295e">SessionAckEnd</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#1ceb9cc924f05bf9d096e696d7519a54">HostInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.host.init</a> RPC by the browser.  <a href="#1ceb9cc924f05bf9d096e696d7519a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#8e4f8b5a2239bc4786415ec522ba7ec4">HostStart</a> (const char *gameMode, const char *<a class="el" href="a04414.html#e296d8b4d8606c50bb299c56e6461c27">level</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostStart is called when the game is sent the game.host.start RPC by the browser.  <a href="#8e4f8b5a2239bc4786415ec522ba7ec4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#deb95f9bec410e796637b813840c6878">HostPlay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostPlay should begin game play.  <a href="#deb95f9bec410e796637b813840c6878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#991b8983de36300b7e6ced46344ae025">HostEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostEnd is called when the game is sent the <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.host.end</a> RPC by the browser.  <a href="#991b8983de36300b7e6ced46344ae025"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#e9a9588129d016a7b6a9d41eb596d971">HostOver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a game ends naturally (e.g.  <a href="#e9a9588129d016a7b6a9d41eb596d971"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#37ae5044e97c5f56cd8c25dbdf07fc0c">HostAckEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostAckEnd is called when the game recevies game.host.ackEnd from the browser.  <a href="#37ae5044e97c5f56cd8c25dbdf07fc0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#dd61bee4856cd4b14c514a3c644fe46f">HostShutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostShutdown is called then the game recevies <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.host.shutdown</a> from the browser.  <a href="#dd61bee4856cd4b14c514a3c644fe46f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#c44530ee1da87428b98c8c090f6f7c86">HostAddPlayer</a> (const char *userId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostAddPlayer is called when a new player attempts to join the session.  <a href="#c44530ee1da87428b98c8c090f6f7c86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#f416e25f978b569715041c90fce91325">HostRemovePlayer</a> (const char *userId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostRemovePlayer is called when a player leaves the session.  <a href="#f416e25f978b569715041c90fce91325"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#59a0781281217f001806bdf9586d47cc">HostRegistrationComplete</a> (GGCError result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HostRegistrationComplete is called when the host's session is registered with our lobby system.  <a href="#59a0781281217f001806bdf9586d47cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#fc0be0c268799e437e1d3a1e6e51dafe">SpInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.sp.init</a> RPC by the browser.  <a href="#fc0be0c268799e437e1d3a1e6e51dafe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#556ffc64b5e33386652e5684f0110528">SpStart</a> (const char *gameMode, const char *<a class="el" href="a04414.html#e296d8b4d8606c50bb299c56e6461c27">level</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpStart is called when the game is sent the game.sp.start RPC by the browser.  <a href="#556ffc64b5e33386652e5684f0110528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#7460680a58f0936dea73ea5cf656b22b">SpPlay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpPlay should begin game play.  <a href="#7460680a58f0936dea73ea5cf656b22b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#98e8ee49b491a535d7121a921d06dd18">SpEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpEnd is called when the game is sent the <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.sp.end</a> RPC by the browser.  <a href="#98e8ee49b491a535d7121a921d06dd18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#9e34f627b4a96d0a776a7aaaccae1489">SpOver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a game ends naturally (e.g.  <a href="#9e34f627b4a96d0a776a7aaaccae1489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#a7b3faa3c962b5ba0343372d2dcd6420">SpAckEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpAckEnd is called when the game recevies game.sp.ackEnd from the browser.  <a href="#a7b3faa3c962b5ba0343372d2dcd6420"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#c7fde8f64d75b1a66f95f5f7ff67e44a">SpShutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SpShutdown is called then the game recevies <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.sp.shutdown</a> from the browser.  <a href="#c7fde8f64d75b1a66f95f5f7ff67e44a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#d8a53ab7b38884409830bb303ddb451a">ClientInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.client.init</a> RPC by the browser.  <a href="#d8a53ab7b38884409830bb303ddb451a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#b8c7dd1524076ddb2d2bb06a0cdd178d">ClientStart</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientStart is called when the game sends game.client.start to itself, which it should do once connected to the host and notified by the host that a level is starting.  <a href="#b8c7dd1524076ddb2d2bb06a0cdd178d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#27acbba71f0a5faa238bf995a9a84ab1">ClientPlay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientPlay is called when the game sends game.client.play to itself, which it should do once it has finished loading the level indicated in <a class="el" href="a03021.html#b8c7dd1524076ddb2d2bb06a0cdd178d">ClientStart()</a>.  <a href="#27acbba71f0a5faa238bf995a9a84ab1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#ff86e89940c6f6beac0c30e87da2d75e">ClientEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientEnd is called when the game sends <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.client.end</a> to itself, which it should do when the host notifies the client that the session is ending prematurely.  <a href="#ff86e89940c6f6beac0c30e87da2d75e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#b385d4c5ce801d12e5cbbc0952908e0e">ClientOver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientOver is called when the game sends game.client.over to itself, which it should do when the host notifies the client that the session ended "naturally" (e.g.  <a href="#b385d4c5ce801d12e5cbbc0952908e0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#0a7a43d79558c8353d0a1042237aa89f">ClientAckEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientAckEnd is called when the game sends game.client.ackEnd to itself, which it should do when the host notifies the client that it has received game.host.ackEnd from the browser.  <a href="#0a7a43d79558c8353d0a1042237aa89f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#62529ca08b141ec95f13f486328ceb7a">ClientShutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientShutdown is called when the browser sends <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.client.shutdown</a> Client-specific resoures should be torn down here.  <a href="#62529ca08b141ec95f13f486328ceb7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#99fb4b025707363059486343f22e3979">ClientRegistrationComplete</a> (GGCError result, const char *hostIp, const char *hostPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ClientRegistrationComplete is called when the client joins a lobby.  <a href="#99fb4b025707363059486343f22e3979"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#236a517f7431945c1c1c4caf3db604cf">Message</a> (const char *msg)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a03443.html">Message</a> is called when the game receives a message packet from the browser.  <a href="#236a517f7431945c1c1c4caf3db604cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04954.html">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#5f99bebabebdbb8b68e6d62335006f67">AllowLanOnlyGames</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a03021.html#5f99bebabebdbb8b68e6d62335006f67">AllowLanOnlyGames()</a> should return whether or not the game supports local network games.  <a href="#5f99bebabebdbb8b68e6d62335006f67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04954.html">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#f7700e9178019edeafe809241f89604b">AllowTURNServer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a03021.html#f7700e9178019edeafe809241f89604b">AllowTURNServer()</a> should return whether or not the game supports TURN, which is a form of traffic proxying.  <a href="#f7700e9178019edeafe809241f89604b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04954.html">bool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#ec21320f61c0c8475052652fead57aa0">DefaultCommandHandler</a> (const char *command, GGCArguments *arguments, GGCError *outResult, GGCCommand *commandObject)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to handle arbitary RPC commands in your <a class="el" href="a03021.html">GameInterface</a>.  <a href="#ec21320f61c0c8475052652fead57aa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#46604b1ebd78b693f72dc54bf579301a">GetVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override this method to handle the game.getVersion RPC.  <a href="#46604b1ebd78b693f72dc54bf579301a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#9a367537257c3359ad42fa36b5d89cd1">OwnershipRefreshed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the ownership cache has been refreshed.  <a href="#9a367537257c3359ad42fa36b5d89cd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#a4c815b28233ebb6379ddea4c4141479">DynamicOwnershipStarted</a> (GGCError result, GGCArguments *arguments)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework when a user is using dynamic ownership (e.g.  <a href="#a4c815b28233ebb6379ddea4c4141479"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#fcdfe6b1e856cdb630267bcd258df155">DynamicOwnershipEnded</a> (GGCError result, GGCArguments *arguments)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework when a user is using dynamic ownership (e.g.  <a href="#fcdfe6b1e856cdb630267bcd258df155"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#8a0bff086a8254a718234d7f59da7f9e">InstallContent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework to alert the game that new content was installed.  <a href="#8a0bff086a8254a718234d7f59da7f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#6c160fee128fde9a92bd30a0525d6d71">PreferencesUpdated</a> (GGCArguments *preferences, GGCError result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework in response to <a class="el" href="a04908.html#5cf39fe17774a1d822c3514deb28c55a">GGConnectInterface::GetPreferences()</a> Game should cache the results locally, as the object will go out of scope when the method returns.  <a href="#6c160fee128fde9a92bd30a0525d6d71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#aa8f0d1b8b45a8e695e516209f4f4390">StatsGroupLoaded</a> (GGCError result, GGCStatsGroup *group)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the frmaework in response to GGConnectInterface::GetStatsGroup() The resultant group object will be loaded with the current values from middleware, or defaults defined in the manifest if this is the first time a player has played this game.  <a href="#aa8f0d1b8b45a8e695e516209f4f4390"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#4d416cfda4175ccddfe5bc5f28b2818f">ShutdownRequested</a> (GGCError error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework in response to a fatal error.  <a href="#4d416cfda4175ccddfe5bc5f28b2818f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#1c1891d3ab5e6a0ead84e4232efa0b1e">GameInterface</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#8575d57f99268c318d659451f291de20">~GameInterface</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Dedicated Server related</div></td></tr>
<tr><td colspan="2"><div class="groupText">@( <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#795a1369b6b578a36b794ae087e71c7a">DedicatedHeartbeat</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the framework when the dedicated server harness has not seen any RPC traffic with the dedicated server in some set amount of time.  <a href="#795a1369b6b578a36b794ae087e71c7a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Demo Viewer</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual GGCError&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#92214ab6b144ebe0aeb1e90f8679fb54">DemoPlay</a> (const char *demoFile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: DemoPlay is called when a player initiates a demo playback via the web interface.  <a href="#92214ab6b144ebe0aeb1e90f8679fb54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#6d3420374e77a7bfdf364dc71a2207de">DemoPause</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: DemoPause is called when a playing demo should be paused.  <a href="#6d3420374e77a7bfdf364dc71a2207de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html#b3e21d7b2411856ae214c31bf8553769">DemoStop</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: DemoStop is called when a playing demo should be stopped.  <a href="#b3e21d7b2411856ae214c31bf8553769"></a><br></td></tr>
</table>
<hr><h2><a name = "HeaderLink3"></a><a name = "HeaderLink3"></a>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1c1891d3ab5e6a0ead84e4232efa0b1e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GameInterface" ref="1c1891d3ab5e6a0ead84e4232efa0b1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GGConnectInterface::GameInterface::GameInterface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8575d57f99268c318d659451f291de20"></a><!-- doxytag: member="GGConnectInterface::GameInterface::~GameInterface" ref="8575d57f99268c318d659451f291de20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGConnectInterface::GameInterface::~GameInterface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2><a name = "HeaderLink4"></a><a name = "HeaderLink4"></a>Member Function Documentation</h2>
<a class="anchor" name="828808a6619756a1cd79deefabbdde82"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GameReady" ref="828808a6619756a1cd79deefabbdde82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::GameReady           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GameReady is called when the game wants to signal that it is fully ready to process commands from the browser. 
<p>

</div>
</div><p>
<a class="anchor" name="b3104f564837f8a7f7362b6d4f7c7a08"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GameInit" ref="b3104f564837f8a7f7362b6d4f7c7a08" args="(const char *videoMode, bool dedicated)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::GameInit           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>videoMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a04954.html">bool</a>&nbsp;</td>
          <td class="paramname"> <em>dedicated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GameInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.init</a> RPC by the browser. 
<p>
The game should initialize it's video at this time. 
</div>
</div><p>
<a class="anchor" name="8b8ea0685e7410f2de372e0b0c2e8162"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GameShutdown" ref="8b8ea0685e7410f2de372e0b0c2e8162" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::GameShutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GameInit is called when the game is sent the <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.shutdown</a> RPC by the browser. 
<p>
All resources should be torn down at this time. 
</div>
</div><p>
<a class="anchor" name="513ae78e91d2900697816eec46a05cf1"></a><!-- doxytag: member="GGConnectInterface::GameInterface::BlurSession" ref="513ae78e91d2900697816eec46a05cf1" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::BlurSession           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BlurSession is called when the game is trying to be blurred (paused). 
<p>

</div>
</div><p>
<a class="anchor" name="d83341cfaaefa17f5d7524061df46850"></a><!-- doxytag: member="GGConnectInterface::GameInterface::FocusSession" ref="d83341cfaaefa17f5d7524061df46850" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::FocusSession           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FocusSession is called when the game wants to focus (unpause). 
<p>

</div>
</div><p>
<a class="anchor" name="521263736a5029d33acde8b2f3676504"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SetFocus" ref="521263736a5029d33acde8b2f3676504" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SetFocus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GGC framework will call this method when your game should grab keyboard and mouse focus. 
<p>
Your game should never grab focus through any other means EXCEPT for the user clicking on your window. 
</div>
</div><p>
<a class="anchor" name="d43572b7b1673b93872b5ac82abcdd4c"></a><!-- doxytag: member="GGConnectInterface::GameInterface::FullscreenOn" ref="d43572b7b1673b93872b5ac82abcdd4c" args="(const char *videoMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::FullscreenOn           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>videoMode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FullscreenOn is called when the fullscreen preference is turned on. 
<p>

</div>
</div><p>
<a class="anchor" name="2d74e0cbe58326d2e3a2856d60b74059"></a><!-- doxytag: member="GGConnectInterface::GameInterface::FullscreenOff" ref="2d74e0cbe58326d2e3a2856d60b74059" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::FullscreenOff           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FullscreenOff is called when the fullscreen preference is turned off. 
<p>

</div>
</div><p>
<a class="anchor" name="731588ff5e672fa13534a80fe693341f"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DoFullscreen" ref="731588ff5e672fa13534a80fe693341f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::DoFullscreen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
DoFullscreen is called when the game should begin displaying fullscreen. 
<p>

</div>
</div><p>
<a class="anchor" name="1f9aa7948539a93e9b185f4c7cff8d53"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DoWindowed" ref="1f9aa7948539a93e9b185f4c7cff8d53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::DoWindowed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
DoWindowed is called when the game should stop displaying fullscreen. 
<p>

</div>
</div><p>
<a class="anchor" name="a7b10eae2c9a7b9200d76e5280df7f37"></a><!-- doxytag: member="GGConnectInterface::GameInterface::RestoreWindow" ref="a7b10eae2c9a7b9200d76e5280df7f37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::RestoreWindow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RestoreWindow is called to "maximize" a fullscreen game. 
<p>

</div>
</div><p>
<a class="anchor" name="824549320047e09788f5ffa62dc1b4cc"></a><!-- doxytag: member="GGConnectInterface::GameInterface::MinimizeWindow" ref="824549320047e09788f5ffa62dc1b4cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::MinimizeWindow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
MinimzeWindow is called to minimize a fullscreen game. 
<p>

</div>
</div><p>
<a class="anchor" name="43511307559ff761b620b449343c9716"></a><!-- doxytag: member="GGConnectInterface::GameInterface::WidgetLoad" ref="43511307559ff761b620b449343c9716" args="(const char *widgetName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::WidgetLoad           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>widgetName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WidgetLoad is called by the browser to request loading of a widget. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>(bool) True if the widget was found, false if this is not the name of a real widget. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a4883e7b4936946b7d37e1cc00d015e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::WidgetStart" ref="9a4883e7b4936946b7d37e1cc00d015e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::WidgetStart           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WidgetStart is called by the game to indicate the widget is ready for display. 
<p>

</div>
</div><p>
<a class="anchor" name="b6008f6c4869fddc01ce4da3cccc6c22"></a><!-- doxytag: member="GGConnectInterface::GameInterface::WidgetSave" ref="b6008f6c4869fddc01ce4da3cccc6c22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* GGConnectInterface::GameInterface::WidgetSave           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WidgetSave is called by the game or browser to save settings in a widget. 
<p>

</div>
</div><p>
<a class="anchor" name="85fd22ee7dd3f254353bc8caeb117dc4"></a><!-- doxytag: member="GGConnectInterface::GameInterface::WidgetCancel" ref="85fd22ee7dd3f254353bc8caeb117dc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::WidgetCancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WidgetCancel is called by the game or browser to cancel a widget. 
<p>

</div>
</div><p>
<a class="anchor" name="3b5b3ad877febe943a7d2e536f33f15c"></a><!-- doxytag: member="GGConnectInterface::GameInterface::WidgetClose" ref="3b5b3ad877febe943a7d2e536f33f15c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::WidgetClose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WidgetClose is called by the browser when it is safe to stop rendering the widget. 
<p>

</div>
</div><p>
<a class="anchor" name="09a676861664b6632dae23794a3a847b"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ShowGameMenu" ref="09a676861664b6632dae23794a3a847b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ShowGameMenu           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show the in-game menu. 
<p>
This is only used for games that do not have a Web UI but rather show all their options in-game. Return GGC_ERROR_None to allow the menu to be shown. 
</div>
</div><p>
<a class="anchor" name="11d39f0bf6fbdc324d487d4947898185"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HideGameMenu" ref="11d39f0bf6fbdc324d487d4947898185" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HideGameMenu           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hide the in-game menu. 
<p>

</div>
</div><p>
<a class="anchor" name="bd1c1654b51347ec06f2387eec43df51"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GameMenuHidden" ref="bd1c1654b51347ec06f2387eec43df51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::GameMenuHidden           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies the game that the in-game menu was hidden. 
<p>

</div>
</div><p>
<a class="anchor" name="290806e980dee86ed4412bdc52f7bced"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SessionQuit" ref="290806e980dee86ed4412bdc52f7bced" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SessionQuit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a6e390bc21b27075991247e5fe8f0547"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SessionOver" ref="a6e390bc21b27075991247e5fe8f0547" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SessionOver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9dd63e91349a811b91446f31b3ed295e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SessionAckEnd" ref="9dd63e91349a811b91446f31b3ed295e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SessionAckEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ceb9cc924f05bf9d096e696d7519a54"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostInit" ref="1ceb9cc924f05bf9d096e696d7519a54" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostInit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.host.init</a> RPC by the browser. 
<p>
Multiplayer-specific host resources should be created here. 
</div>
</div><p>
<a class="anchor" name="8e4f8b5a2239bc4786415ec522ba7ec4"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostStart" ref="8e4f8b5a2239bc4786415ec522ba7ec4" args="(const char *gameMode, const char *level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostStart           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gameMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostStart is called when the game is sent the game.host.start RPC by the browser. 
<p>
The game should begin loading the passed-in level and game mode, then issue game.host.play to itself once the level is ready to play. 
</div>
</div><p>
<a class="anchor" name="deb95f9bec410e796637b813840c6878"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostPlay" ref="deb95f9bec410e796637b813840c6878" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostPlay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostPlay should begin game play. 
<p>

</div>
</div><p>
<a class="anchor" name="991b8983de36300b7e6ced46344ae025"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostEnd" ref="991b8983de36300b7e6ced46344ae025" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostEnd is called when the game is sent the <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.host.end</a> RPC by the browser. 
<p>
This means the game was forcefully ended by the player via the browser UI. 
</div>
</div><p>
<a class="anchor" name="e9a9588129d016a7b6a9d41eb596d971"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostOver" ref="e9a9588129d016a7b6a9d41eb596d971" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostOver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If a game ends naturally (e.g. 
<p>
game time limit expires or goal is reach) The game should send game.host.over to itself, which triggers <a class="el" href="a03021.html#e9a9588129d016a7b6a9d41eb596d971">HostOver()</a>. 
</div>
</div><p>
<a class="anchor" name="37ae5044e97c5f56cd8c25dbdf07fc0c"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostAckEnd" ref="37ae5044e97c5f56cd8c25dbdf07fc0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostAckEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostAckEnd is called when the game recevies game.host.ackEnd from the browser. 
<p>
This will be sent in response to the SessionEnded notification, which is generated via the game.host.over RPC. 
</div>
</div><p>
<a class="anchor" name="dd61bee4856cd4b14c514a3c644fe46f"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostShutdown" ref="dd61bee4856cd4b14c514a3c644fe46f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostShutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostShutdown is called then the game recevies <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.host.shutdown</a> from the browser. 
<p>

</div>
</div><p>
<a class="anchor" name="c44530ee1da87428b98c8c090f6f7c86"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostAddPlayer" ref="c44530ee1da87428b98c8c090f6f7c86" args="(const char *userId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostAddPlayer           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>userId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostAddPlayer is called when a new player attempts to join the session. 
<p>
Return GGC_ERROR_None to allow the player to join, any other result to reject the player. 
</div>
</div><p>
<a class="anchor" name="f416e25f978b569715041c90fce91325"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostRemovePlayer" ref="f416e25f978b569715041c90fce91325" args="(const char *userId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostRemovePlayer           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>userId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostRemovePlayer is called when a player leaves the session. 
<p>

</div>
</div><p>
<a class="anchor" name="59a0781281217f001806bdf9586d47cc"></a><!-- doxytag: member="GGConnectInterface::GameInterface::HostRegistrationComplete" ref="59a0781281217f001806bdf9586d47cc" args="(GGCError result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::HostRegistrationComplete           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
HostRegistrationComplete is called when the host's session is registered with our lobby system. 
<p>
If the result is not GGC_ERROR_None, a registration error occured. 
</div>
</div><p>
<a class="anchor" name="fc0be0c268799e437e1d3a1e6e51dafe"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpInit" ref="fc0be0c268799e437e1d3a1e6e51dafe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpInit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.sp.init</a> RPC by the browser. 
<p>
Single player-specific resources should be created here. 
</div>
</div><p>
<a class="anchor" name="556ffc64b5e33386652e5684f0110528"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpStart" ref="556ffc64b5e33386652e5684f0110528" args="(const char *gameMode, const char *level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpStart           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gameMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpStart is called when the game is sent the game.sp.start RPC by the browser. 
<p>
The game should begin loading the passed-in level and game mode, then issue game.sp.play to itself once the level is ready to play. 
</div>
</div><p>
<a class="anchor" name="7460680a58f0936dea73ea5cf656b22b"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpPlay" ref="7460680a58f0936dea73ea5cf656b22b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpPlay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpPlay should begin game play. 
<p>

</div>
</div><p>
<a class="anchor" name="98e8ee49b491a535d7121a921d06dd18"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpEnd" ref="98e8ee49b491a535d7121a921d06dd18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpEnd is called when the game is sent the <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.sp.end</a> RPC by the browser. 
<p>
This means the game was forcefully ended by the player via the browser UI. 
</div>
</div><p>
<a class="anchor" name="9e34f627b4a96d0a776a7aaaccae1489"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpOver" ref="9e34f627b4a96d0a776a7aaaccae1489" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpOver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If a game ends naturally (e.g. 
<p>
game time limit expires or goal is reach) The game should send game.sp.over to itself, which triggers <a class="el" href="a03021.html#9e34f627b4a96d0a776a7aaaccae1489">SpOver()</a>. 
</div>
</div><p>
<a class="anchor" name="a7b3faa3c962b5ba0343372d2dcd6420"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpAckEnd" ref="a7b3faa3c962b5ba0343372d2dcd6420" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpAckEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpAckEnd is called when the game recevies game.sp.ackEnd from the browser. 
<p>
This will be sent in response to the SessionEnded notification, which is generated via the game.sp.over RPC. 
</div>
</div><p>
<a class="anchor" name="c7fde8f64d75b1a66f95f5f7ff67e44a"></a><!-- doxytag: member="GGConnectInterface::GameInterface::SpShutdown" ref="c7fde8f64d75b1a66f95f5f7ff67e44a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::SpShutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SpShutdown is called then the game recevies <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.sp.shutdown</a> from the browser. 
<p>

</div>
</div><p>
<a class="anchor" name="d8a53ab7b38884409830bb303ddb451a"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientInit" ref="d8a53ab7b38884409830bb303ddb451a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientInit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientInit is called when the game is sent the <a class="el" href="a04917.html#6819e34e322fd06c1eef600a08efc01f">game.client.init</a> RPC by the browser. 
<p>
Client-specific resources should be created here. 
</div>
</div><p>
<a class="anchor" name="b8c7dd1524076ddb2d2bb06a0cdd178d"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientStart" ref="b8c7dd1524076ddb2d2bb06a0cdd178d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientStart           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientStart is called when the game sends game.client.start to itself, which it should do once connected to the host and notified by the host that a level is starting. 
<p>

</div>
</div><p>
<a class="anchor" name="27acbba71f0a5faa238bf995a9a84ab1"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientPlay" ref="27acbba71f0a5faa238bf995a9a84ab1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientPlay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientPlay is called when the game sends game.client.play to itself, which it should do once it has finished loading the level indicated in <a class="el" href="a03021.html#b8c7dd1524076ddb2d2bb06a0cdd178d">ClientStart()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="ff86e89940c6f6beac0c30e87da2d75e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientEnd" ref="ff86e89940c6f6beac0c30e87da2d75e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientEnd is called when the game sends <a class="el" href="a04921.html#799adae636905285b1a8c1e97e1316a7">game.client.end</a> to itself, which it should do when the host notifies the client that the session is ending prematurely. 
<p>

</div>
</div><p>
<a class="anchor" name="b385d4c5ce801d12e5cbbc0952908e0e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientOver" ref="b385d4c5ce801d12e5cbbc0952908e0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientOver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientOver is called when the game sends game.client.over to itself, which it should do when the host notifies the client that the session ended "naturally" (e.g. 
<p>
round time or score limit reached). 
</div>
</div><p>
<a class="anchor" name="0a7a43d79558c8353d0a1042237aa89f"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientAckEnd" ref="0a7a43d79558c8353d0a1042237aa89f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientAckEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientAckEnd is called when the game sends game.client.ackEnd to itself, which it should do when the host notifies the client that it has received game.host.ackEnd from the browser. 
<p>

</div>
</div><p>
<a class="anchor" name="62529ca08b141ec95f13f486328ceb7a"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientShutdown" ref="62529ca08b141ec95f13f486328ceb7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientShutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientShutdown is called when the browser sends <a class="el" href="a04930.html#8f5ea5f7f775ff7a486ac0efc6dc4aa5">game.client.shutdown</a> Client-specific resoures should be torn down here. 
<p>

</div>
</div><p>
<a class="anchor" name="99fb4b025707363059486343f22e3979"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ClientRegistrationComplete" ref="99fb4b025707363059486343f22e3979" args="(GGCError result, const char *hostIp, const char *hostPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::ClientRegistrationComplete           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostIp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ClientRegistrationComplete is called when the client joins a lobby. 
<p>
The result will be GGC_ERROR_None if the lobby was joined successfully, in which case hostIp and hostPort will be valid. Otherwise the client could not join, and hostIp and hostPort will be NULL. 
</div>
</div><p>
<a class="anchor" name="236a517f7431945c1c1c4caf3db604cf"></a><!-- doxytag: member="GGConnectInterface::GameInterface::Message" ref="236a517f7431945c1c1c4caf3db604cf" args="(const char *msg)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::Message           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="a03443.html">Message</a> is called when the game receives a message packet from the browser. 
<p>
Messages have been deprecated in favor of RPC commands, so most games will not need to do anything in this method. 
</div>
</div><p>
<a class="anchor" name="5f99bebabebdbb8b68e6d62335006f67"></a><!-- doxytag: member="GGConnectInterface::GameInterface::AllowLanOnlyGames" ref="5f99bebabebdbb8b68e6d62335006f67" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04954.html">bool</a> GGConnectInterface::GameInterface::AllowLanOnlyGames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="a03021.html#5f99bebabebdbb8b68e6d62335006f67">AllowLanOnlyGames()</a> should return whether or not the game supports local network games. 
<p>

</div>
</div><p>
<a class="anchor" name="f7700e9178019edeafe809241f89604b"></a><!-- doxytag: member="GGConnectInterface::GameInterface::AllowTURNServer" ref="f7700e9178019edeafe809241f89604b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04954.html">bool</a> GGConnectInterface::GameInterface::AllowTURNServer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="a03021.html#f7700e9178019edeafe809241f89604b">AllowTURNServer()</a> should return whether or not the game supports TURN, which is a form of traffic proxying. 
<p>
The <a class="el" href="a04908.html">GGConnectInterface</a> handles the details of TURN, but games which are very sensitive to network latency should return false. 
</div>
</div><p>
<a class="anchor" name="ec21320f61c0c8475052652fead57aa0"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DefaultCommandHandler" ref="ec21320f61c0c8475052652fead57aa0" args="(const char *command, GGCArguments *arguments, GGCError *outResult, GGCCommand *commandObject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04954.html">bool</a> GGConnectInterface::GameInterface::DefaultCommandHandler           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCArguments *&nbsp;</td>
          <td class="paramname"> <em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCError *&nbsp;</td>
          <td class="paramname"> <em>outResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCCommand *&nbsp;</td>
          <td class="paramname"> <em>commandObject</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Override this method to handle arbitary RPC commands in your <a class="el" href="a03021.html">GameInterface</a>. 
<p>
If you handle a command, you should set *outResult to the result, and return true. If you return false, the framework will reply with GGC_ERROR_UnhandledRequest. 
</div>
</div><p>
<a class="anchor" name="46604b1ebd78b693f72dc54bf579301a"></a><!-- doxytag: member="GGConnectInterface::GameInterface::GetVersion" ref="46604b1ebd78b693f72dc54bf579301a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* GGConnectInterface::GameInterface::GetVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Override this method to handle the game.getVersion RPC. 
<p>
In which case, you should return a string that can uniquely identify a build of your game. 
</div>
</div><p>
<a class="anchor" name="9a367537257c3359ad42fa36b5d89cd1"></a><!-- doxytag: member="GGConnectInterface::GameInterface::OwnershipRefreshed" ref="9a367537257c3359ad42fa36b5d89cd1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::OwnershipRefreshed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the ownership cache has been refreshed. 
<p>
Game should recheck ownership for content at this time. 
</div>
</div><p>
<a class="anchor" name="a4c815b28233ebb6379ddea4c4141479"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DynamicOwnershipStarted" ref="a4c815b28233ebb6379ddea4c4141479" args="(GGCError result, GGCArguments *arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::DynamicOwnershipStarted           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCArguments *&nbsp;</td>
          <td class="paramname"> <em>arguments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework when a user is using dynamic ownership (e.g. 
<p>
pay to play) and the back-end returns a response. If result in an error, Game can shutdown or otherwise disable the content in question. 
</div>
</div><p>
<a class="anchor" name="fcdfe6b1e856cdb630267bcd258df155"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DynamicOwnershipEnded" ref="fcdfe6b1e856cdb630267bcd258df155" args="(GGCError result, GGCArguments *arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::DynamicOwnershipEnded           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCArguments *&nbsp;</td>
          <td class="paramname"> <em>arguments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework when a user is using dynamic ownership (e.g. 
<p>
pay to play) and the back-end returns a response. 
</div>
</div><p>
<a class="anchor" name="8a0bff086a8254a718234d7f59da7f9e"></a><!-- doxytag: member="GGConnectInterface::GameInterface::InstallContent" ref="8a0bff086a8254a718234d7f59da7f9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::InstallContent           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework to alert the game that new content was installed. 
<p>
Game should refresh any indices it keeps for local game content. 
</div>
</div><p>
<a class="anchor" name="6c160fee128fde9a92bd30a0525d6d71"></a><!-- doxytag: member="GGConnectInterface::GameInterface::PreferencesUpdated" ref="6c160fee128fde9a92bd30a0525d6d71" args="(GGCArguments *preferences, GGCError result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::PreferencesUpdated           </td>
          <td>(</td>
          <td class="paramtype">GGCArguments *&nbsp;</td>
          <td class="paramname"> <em>preferences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework in response to <a class="el" href="a04908.html#5cf39fe17774a1d822c3514deb28c55a">GGConnectInterface::GetPreferences()</a> Game should cache the results locally, as the object will go out of scope when the method returns. 
<p>

</div>
</div><p>
<a class="anchor" name="aa8f0d1b8b45a8e695e516209f4f4390"></a><!-- doxytag: member="GGConnectInterface::GameInterface::StatsGroupLoaded" ref="aa8f0d1b8b45a8e695e516209f4f4390" args="(GGCError result, GGCStatsGroup *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::StatsGroupLoaded           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GGCStatsGroup *&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the frmaework in response to GGConnectInterface::GetStatsGroup() The resultant group object will be loaded with the current values from middleware, or defaults defined in the manifest if this is the first time a player has played this game. 
<p>

</div>
</div><p>
<a class="anchor" name="4d416cfda4175ccddfe5bc5f28b2818f"></a><!-- doxytag: member="GGConnectInterface::GameInterface::ShutdownRequested" ref="4d416cfda4175ccddfe5bc5f28b2818f" args="(GGCError error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::ShutdownRequested           </td>
          <td>(</td>
          <td class="paramtype">GGCError&nbsp;</td>
          <td class="paramname"> <em>error</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework in response to a fatal error. 
<p>
The game should initiate a shutdown in this method. It does not need to shutdown immediately, instead it should trigger the game loop to exit. 
</div>
</div><p>
<a class="anchor" name="795a1369b6b578a36b794ae087e71c7a"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DedicatedHeartbeat" ref="795a1369b6b578a36b794ae087e71c7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::DedicatedHeartbeat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the framework when the dedicated server harness has not seen any RPC traffic with the dedicated server in some set amount of time. 
<p>
Game should always return GGC_ERROR_None. If the harness does not receive a reply to this message, it will assume the dedicated server is hung and recycle it. 
</div>
</div><p>
<a class="anchor" name="92214ab6b144ebe0aeb1e90f8679fb54"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DemoPlay" ref="92214ab6b144ebe0aeb1e90f8679fb54" args="(const char *demoFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GGCError GGConnectInterface::GameInterface::DemoPlay           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>demoFile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EXPERIMENTAL: DemoPlay is called when a player initiates a demo playback via the web interface. 
<p>
At this point the game should begin to play back the demo returning GGC_ERROR_None to indicate success. Note that your engine must support Demo recording and playback, the IA SDK does not provide this functionality. 
</div>
</div><p>
<a class="anchor" name="6d3420374e77a7bfdf364dc71a2207de"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DemoPause" ref="6d3420374e77a7bfdf364dc71a2207de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::DemoPause           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EXPERIMENTAL: DemoPause is called when a playing demo should be paused. 
<p>

</div>
</div><p>
<a class="anchor" name="b3e21d7b2411856ae214c31bf8553769"></a><!-- doxytag: member="GGConnectInterface::GameInterface::DemoStop" ref="b3e21d7b2411856ae214c31bf8553769" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a04909.html#80aca66f10d7fcb78d09f20cdf4490bc">void</a> GGConnectInterface::GameInterface::DemoStop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EXPERIMENTAL: DemoStop is called when a playing demo should be stopped. 
<p>

</div>
</div><p>
  </td>
</tr>
</table>

</div>
<div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div><div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>

<!-- Mirrored from docs.garagegames.com/tgea/official/content/documentation/Engine Reference/a03021.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:40:51 GMT -->
</html>
